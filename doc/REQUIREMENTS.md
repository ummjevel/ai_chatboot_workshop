# AI 챗봇 멘토링 커리큘럼 코드 생성 프롬프트

## 전체 요구사항

7차시 AI 챗봇 멘토링 커리큘럼의 실습용 코드를 생성해주세요. 개발자 대상이며 핸즈온 중심(90%)으로 진행되는 실무 멘토링입니다.

### 기본 설정
- **언어**: Python (주), JavaScript (프론트엔드)
- **주요 라이브러리**: OpenAI, LangChain, Streamlit/FastAPI, Redis
- **난이도**: 중급 개발자 수준 (컴공과 재학생 일부 포함)
- **목적**: 실무에서 바로 사용 가능한 코드 제공

## 전체 코드 생성 가이드라인

### 코드 구조
- **뼈대 중심**: 핵심 로직과 구조만 구현, 세부 기능은 TODO로 표시
- **최소화 원칙**: 각 모듈당 50-100줄 내외로 간결하게 작성
- **확장 가능**: 기본 틀을 제공하고 확장 포인트 명시

### 파일 구조 필수사항
- **Jupyter Notebook (.ipynb)**: 단계별 실습용, 셀별로 구분된 학습형 코드
  - 각 셀에 실행 결과와 설명 마크다운 포함
  - 중간중간 체크포인트와 테스트 코드 삽입
  - 시각화 및 출력 결과 표시
- **Python 파일 (.py)**: 완전한 통합 코드, 프로덕션 사용 가능
  - 전체 기능을 하나의 실행 가능한 파일로 통합
  - 클래스/함수 기반 모듈화 구조
  - CLI 인터페이스 포함

### 주석 작성 가이드라인
- **함수/클래스**: docstring으로 목적, 파라미터, 반환값, 예시 포함
- **복잡한 로직**: 단계별 상세 설명
- **설정값**: 왜 이 값을 사용하는지 이유 설명
- **TODO/FIXME**: 향후 개선점과 확장 방향성 명시
- **예외 처리**: 어떤 상황에서 발생하는지 설명
- **성능 고려사항**: 최적화 포인트와 트레이드오프 설명

### 예시 주석 스타일
```python
def process_user_message(message: str, user_id: str) -> Dict[str, Any]:
    """
    사용자 메시지를 처리하고 응답을 생성합니다.
    
    Args:
        message (str): 사용자 입력 메시지
        user_id (str): 세션 식별을 위한 사용자 ID
    
    Returns:
        Dict[str, Any]: {
            'response': str,      # 생성된 응답 텍스트
            'tokens_used': int,   # 사용된 토큰 수
            'processing_time': float  # 처리 시간 (초)
        }
    
    Raises:
        APIError: OpenAI API 호출 실패 시
        ValidationError: 메시지 형식이 잘못된 경우
    
    Example:
        >>> result = process_user_message("안녕하세요", "user123")
        >>> print(result['response'])
        "안녕하세요! 무엇을 도와드릴까요?"
    """
    # TODO: 메시지 전처리 로직 추가 (욕설 필터링, 길이 제한 등)
    
    # 1. 사용자 세션 조회 - Redis에서 이전 대화 내역 가져오기
    session_data = get_user_session(user_id)  # 평균 5ms 소요
    
    # 2. 컨텍스트 윈도우 최적화 - 토큰 수가 4000개 초과 시 압축
    if session_data['total_tokens'] > 4000:
        session_data = compress_context(session_data)  # 30-50% 토큰 절약
    
    # ... 나머지 구현
```

### 디버깅 로깅 필수사항
- **로그 레벨**: DEBUG, INFO, WARNING, ERROR, CRITICAL 전부 활용
- **구조화된 로깅**: JSON 형태로 파싱 가능한 로그 포맷
- **상황별 로깅**:
  - 함수 진입/종료 시점
  - API 호출 전후 (요청/응답 데이터)
  - 에러 발생 시 상세 스택 트레이스
  - 성능 측정 (실행 시간, 토큰 사용량)
  - 사용자 액션 추적
- **로그 컨텍스트**: 요청 ID, 사용자 ID, 세션 ID 추가
- **민감정보 마스킹**: API 키, 개인정보 자동 마스킹

### 예시 로깅 스타일
```python
import logging
import json
from functools import wraps

logger = logging.getLogger(__name__)

def log_function_call(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        logger.debug(f"[ENTER] {func.__name__}", extra={
            "function": func.__name__, 
            "args_count": len(args),
            "kwargs_keys": list(kwargs.keys())
        })
        try:
            result = func(*args, **kwargs)
            logger.debug(f"[EXIT] {func.__name__} - SUCCESS")
            return result
        except Exception as e:
            logger.error(f"[EXIT] {func.__name__} - ERROR: {str(e)}", 
                        extra={"error": str(e), "function": func.__name__})
            raise
    return wrapper
```

---

## 1차시: 실무 환경 구축 & 빠른 프로토타입

### 요청사항
```
환경 구축과 기본 챗봇 구현을 위한 코드를 생성해주세요:

1. **프로젝트 구조**
   - requirements.txt (필수 라이브러리)
   - .env.example (환경변수 템플릿)
   - config.py (설정 관리)
   - main.py (기본 실행 파일)

1. **기본 챗봇 구현**
   - OpenAI API 연동 (뼈대만, 핵심 로직 중심)
   - 스트리밍 응답 구현 (기본 구조만)
   - 상세한 디버깅 로깅 (API 호출 전후, 에러 상황, 응답 시간)
   - 간단한 웹 인터페이스 (Streamlit 기본 틀)

3. **실무 팁 코드**
   - API 키 로테이션 로직
   - 환경별 설정 분리 코드
   - 토큰 사용량 모니터링

실행하면 바로 동작하는 완전한 코드로 만들어주세요.
- **lesson1_basic_chatbot.ipynb**: 단계별 학습용 노트북
- **lesson1_basic_chatbot.py**: 통합 실행 파일
```

---

## 2차시: 프롬프트 실무 최적화

### 요청사항
```
프롬프트 최적화를 위한 실무 코드를 생성해주세요:

1. **프롬프트 템플릿 시스템**
   - Jinja2 기반 동적 프롬프트 생성 (뼈대 구조)
   - 역할별 프롬프트 관리 (기본 틀만)
   - 상세한 디버깅 로깅 (프롬프트 생성 과정, 변수 치환, 토큰 수)

2. **페르소나 및 제약조건 구현**
   - 브랜드 톤앤매너 적용 코드 (기본 구조)
   - 답변 길이/형식 제어 로직 (핵심만)
   - 상세한 로깅 (필터링 과정, 제약조건 적용 여부)

3. **트러블슈팅 해결 코드**
   - temperature=0, seed 고정으로 일관성 확보 (기본 구현)
   - 프롬프트 압축 알고리즘 (뼈대만)
   - 상세한 로깅 (압축 전후 비교, 일관성 체크)

각 기능별로 before/after 비교가 가능한 예시 코드를 포함해주세요.
- **lesson2_prompt_optimization.ipynb**: 단계별 학습용 노트북
- **lesson2_prompt_optimization.py**: 통합 실행 파일
```

---

## 3차시: RAG 실무 구현

### 요청사항
```
RAG 시스템 구현을 위한 실무 코드를 생성해주세요:

1. **문서 처리 파이프라인**
   - PDF/TXT 파일 업로드 및 파싱 (기본 구조만)
   - 스마트 청킹 알고리즘 (핵심 로직만)
   - 상세한 디버깅 로깅 (파일 처리 과정, 청킹 결과, 메타데이터)

2. **검색 시스템**
   - 벡터 임베딩 생성 및 저장 (Chroma/FAISS 기본 틀)
   - 유사도 검색 기본 구현
   - 상세한 로깅 (검색 쿼리, 유사도 점수, 검색 결과)

3. **RAG 응답 생성**
   - 검색 결과 기반 답변 생성 (뼈대만)
   - 출처 표시 기본 구현
   - 상세한 로깅 (검색-생성 전 과정, 품질 메트릭)

실제 PDF를 업로드해서 테스트할 수 있는 완전한 구현체로 만들어주세요.
- **lesson3_rag_implementation.ipynb**: 단계별 학습용 노트북
- **lesson3_rag_implementation.py**: 통합 실행 파일
```

---

## 4차시: 대화 상태 관리 & 멀티턴 최적화

### 요청사항
```
대화 상태 관리를 위한 실무 코드를 생성해주세요:

1. **세션 관리 시스템**
   - Redis 기반 대화 히스토리 저장 (기본 구조)
   - 사용자별 컨텍스트 관리 (핵심 로직만)
   - 상세한 디버깅 로깅 (세션 생성/조회/업데이트, 메모리 사용량)

2. **Context Window 최적화**
   - 토큰 수 기반 메시지 압축 (뼈대 구조)
   - 중요도 기반 대화 요약 (기본 알고리즘)
   - 상세한 로깅 (압축 전후 토큰 수, 요약 과정, 성능 메트릭)

3. **대화 흐름 제어**
   - 의도 분류 및 상태 전환 (기본 틀)
   - 주제 변경 감지 로직 (핵심만)
   - 상세한 로깅 (상태 전환, 의도 분류 결과, 컨텍스트 변화)

멀티 사용자 환경에서 동시에 테스트할 수 있는 구현체로 만들어주세요.
- **lesson4_conversation_management.ipynb**: 단계별 학습용 노트북
- **lesson4_conversation_management.py**: 통합 실행 파일
```

---

## 5차시: 외부 연동 & 실시간 데이터 처리

### 요청사항
```
외부 시스템 연동을 위한 실무 코드를 생성해주세요:

1. **Tool Calling 시스템**
   - OpenAI Function Calling 구현 (기본 틀)
   - 날씨 API, 검색 API 등 외부 API 연동 (뼈대만)
   - 상세한 디버깅 로깅 (도구 선택 과정, API 호출 세부사항, 응답 처리)

2. **데이터베이스 연동**
   - SQLite/PostgreSQL 연결 (기본 구조)
   - 실시간 데이터 조회 (핵심 로직)
   - 상세한 로깅 (쿼리 실행 시간, 결과 집합 크기, 커넥션 상태)

3. **에러 핸들링 및 복구**
   - Circuit breaker 패턴 구현 (뼈대 구조)
   - 재시도 로직 기본 틀
   - 상세한 로깅 (재시도 횟수, 실패 원인, 복구 과정, 성능 영향)

각 외부 연동별로 독립적으로 테스트할 수 있는 모듈 구조로 만들어주세요.
- **lesson5_external_integration.ipynb**: 단계별 학습용 노트북
- **lesson5_external_integration.py**: 통합 실행 파일
```

---

## 6차시: 성능 최적화 & 모니터링

### 요청사항
```
성능 최적화와 모니터링을 위한 실무 코드를 생성해주세요:

1. **성능 최적화**
   - 응답 캐싱 시스템 (Redis)
   - 비동기 처리 및 병렬 실행
   - 스트리밍 응답 최적화

2. **비용 최적화**
   - 토큰 사용량 추적 및 제한
   - 모델 선택 로직 (성능 vs 비용)
   - 프롬프트 압축 알고리즘

3. **모니터링 시스템**
   - 상세한 디버깅 로깅 시스템 구축
   - 메트릭 수집 및 코드 기반 대시보드 구현
   - 알람 시스템 구현

메트릭 수집과 대시보드는 순수 Python 코드로 구현하고, Prometheus/Grafana 연동은 설정 예시만 제공해주세요.
- **lesson6_performance_monitoring.ipynb**: 단계별 학습용 노트북
- **lesson6_performance_monitoring.py**: 통합 실행 파일
```

---

## 7차시: 종합 프로젝트 & 실전 배포

### 요청사항
```
전체 시스템 통합과 배포를 위한 실무 코드를 생성해주세요:

1. **시스템 통합**
   - 모든 모듈을 통합한 챗봇 서비스 (기본 구조만)
   - FastAPI 기반 REST API (핵심 엔드포인트만)
   - 상세한 디버깅 로깅 (요청 처리 전체 과정, 모듈 간 통신)

2. **배포 환경**
   - Dockerfile 및 docker-compose.yml (기본 틀)
   - 환경별 설정 파일 구조
   - 상세한 로깅 (배포 과정, 헬스체크, 환경 설정)

3. **운영 도구**
   - 헬스체크 엔드포인트 (기본 구현)
   - 백업 및 복구 스크립트 뼈대
   - 상세한 로깅 (시스템 상태, 백업 진행률, 복구 과정)

실제 클라우드 환경에 배포할 수 있는 프로덕션 레디 코드로 만들어주세요.
- **lesson7_deployment_integration.ipynb**: 단계별 학습용 노트북
- **lesson7_deployment_integration.py**: 통합 실행 파일
```

---

## 보조 요청사항

### 문서화 요구사항
```
각 시간차별로 다음 문서들도 함께 생성해주세요:

1. **README.md**: 실행 방법, 환경 설정, 트러블슈팅
2. **API 문서**: 엔드포인트별 사용법 및 예시
3. **설정 가이드**: 환경변수, 외부 서비스 연동 방법
4. **FAQ**: 자주 발생하는 문제와 해결책

모든 문서는 초보자도 따라할 수 있을 정도로 상세하게 작성해주세요.
```

### 테스트 코드 요구사항
```
각 기능별로 테스트 코드도 함께 생성해주세요:

1. **Unit Test**: 핵심 함수들의 단위 테스트
2. **Integration Test**: API 연동, DB 연결 테스트
3. **Performance Test**: 부하 테스트, 응답 시간 측정
4. **E2E Test**: 전체 플로우 테스트

pytest 기반으로 작성하고, GitHub Actions에서 자동 실행 가능하도록 해주세요.
```

---

## 추가 고려사항

1. **코드 품질**: PEP8 준수, 타입 힌트 포함, 상세한 주석 작성
2. **파일 구조**: 각 시간차별로 .ipynb + .py 파일 세트 제공
3. **확장성**: 새로운 기능 추가 시 기존 코드 수정 최소화
4. **보안**: API 키 관리, 입력 검증, SQL Injection 방지
5. **사용자 경험**: 명확한 에러 메시지, 로딩 상태 표시
6. **운영 편의성**: 로그 분석 용이, 설정 변경 간편

### Jupyter Notebook 구조 가이드라인
- **셀 1**: 환경 설정 및 라이브러리 import
- **셀 2-3**: 기본 설정 및 테스트 데이터 준비
- **셀 4-N**: 핵심 기능별 단계별 구현
- **마지막 셀**: 통합 테스트 및 결과 시각화

### Python 파일 구조 가이드라인
```python
#!/usr/bin/env python3
"""
차시별 AI 챗봇 멘토링 실습 코드
Author: [작성자]
Date: [날짜]
Description: [해당 차시 목표와 주요 기능]
"""

# 1. Import 섹션
# 2. 설정 및 상수
# 3. 유틸리티 함수들
# 4. 메인 클래스/함수들
# 5. CLI 인터페이스
# 6. if __name__ == "__main__": 실행부
```

각 차시별로 완전히 독립적으로 실행 가능하면서도, 이전 차시의 코드를 활용할 수 있도록 모듈화해주세요.
